<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>AsyncDocumentation</title>
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="AsyncDocumentation";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../io/sphere/sdk/meta/Architecture.html" title="class in io.sphere.sdk.meta"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../io/sphere/sdk/meta/BuildInfo.html" title="class in io.sphere.sdk.meta"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?io/sphere/sdk/meta/AsyncDocumentation.html" target="_top">Frames</a></li>
<li><a href="AsyncDocumentation.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#methods.inherited.from.class.java.lang.Object">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li>Method</li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">io.sphere.sdk.meta</div>
<h2 title="Class AsyncDocumentation" class="title">Class AsyncDocumentation</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>io.sphere.sdk.meta.AsyncDocumentation</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public final class <span class="typeNameLabel">AsyncDocumentation</span>
extends java.lang.Object</pre>
<div class="block"><!-- intro -->

 <h3 id="why">Why</h3>

 If you don't care about threads and asynchronous computation you will probably have a slow and inefficient application.

 <p>Suppose you want to show a customer detail page with the cart items and the customer data, so you need to fetch the cart and the customer.
 Fetching both documents is not related and lets suppose fetching a document from SPHERE.IO takes 100ms.</p>


 <div id="io-sphere-sdk-meta-AsyncDocumentationTest-serialWayToFetchCustomerAndCart--%s" class=code-example><pre><code class='java'>final String customerId = "customer-id";//time t = 0
final Optional&lt;Customer&gt; customerOption = executeSerial(CustomerByIdFetch.of(customerId));//t = 100ms
final Optional&lt;Cart&gt; cartOption = executeSerial(CartByCustomerIdFetch.of(customerId));//t = 200ms
println("cart: " + cartOption + " customer: " + customerOption);
</code><p>See the <a href="https://github.com/sphereio/sphere-jvm-sdk/blob/master/src/test/java/io/sphere/sdk/meta/AsyncDocumentationTest.java" target="_blank">test code</a>.</pre></div>

 <p>So it takes around 200ms since the requests are done one after another. By fetching them in parallel 100ms of time can be saved.</p>

 <div id="io-sphere-sdk-meta-AsyncDocumentationTest-parallelWayToFetchCustomerAndCart--%s" class=code-example><pre><code class='java'>final String customerId = "customer-id";//time t = 0
final CompletionStage&lt;Optional&lt;Customer&gt;&gt; customerStage = execute(CustomerByIdFetch.of(customerId));//t = 1ms
//after creating the CompletionStage the Thread is freed to start further requests
final CompletionStage&lt;Optional&lt;Cart&gt;&gt; cartStage = execute(CartByCustomerIdFetch.of(customerId));//t = 2ms
//collect the results
customerStage.thenAcceptBoth(cartStage, (customerOption, cartOption) -&gt; {
    //t=102ms
    println("cart: " + cartOption + " customer: " + customerOption);
});
</code><p>See the <a href="https://github.com/sphereio/sphere-jvm-sdk/blob/master/src/test/java/io/sphere/sdk/meta/AsyncDocumentationTest.java" target="_blank">test code</a>.</pre></div>

 <p>Using futures (We use it here as synonym for <code>CompletableFuture</code> and <code>CompletionStage</code>.) can be very handy to execute parallel code.</p>

 <p>So you can use future APIs to run code in separate Threads and the result will not be immediately available, but in the future.
 The overhead of creating a future can be lower than <a href="http://stackoverflow.com/a/5483105">overhead of creating new Thread</a>.</p>
 <!--
 <h3 id="what">What</h3>

 <ul>
     <li>monad</li>
link to Wikipedia, give monad laws

     <li>like <code>Optional</code> of a result value, can have a value or not, but this can change over time</li>
     <li>like <code>Optional</code> of an exception, can have an exception or not, but this can change over time</li>

    <li> by default not bound to any thread pool or asynchronous job</li>

 <li>CompletableFuture for filling it, CompletionStage for public API (dev cannot fulfill future), methods in complectionstage also in completablefuture</li>
 <li>CompletionStage.toCompletableFuture</li>
 <li>usage is not a guarantee, that is reactive or non blocking, can still be used wrong</li>
 <li></li>
 <li></li>
 </ul> -->


 <h3 id="functional-composition">Functional Composition </h3>

 Functional composition covers to transform one future into another for the happy cases. <code>CompletionStage.thenApply(java.util.function.Function)</code>
 and <code>CompletionStage.thenCompose(java.util.function.Function)</code> will only be called if the future finishes successfully.




 <h4>ThenApply (map, composition that returns directly a value)</h4>
Mostly, it is easier to reason about side-effect free code. A future is monad so you do not work with the value directly,
 but you provide functions to transform the value or the exception into a new future.

To use a future for further computation you probably need to use <code>CompletionStage.thenApply(java.util.function.Function)</code>.
 <div id="io-sphere-sdk-meta-AsyncDocumentationTest-thenApplyFirstDemo--%s" class=code-example><pre><code class='java'>final String customerId = "customer-id";
final CompletionStage&lt;Optional&lt;Customer&gt;&gt; customerStage = execute(CustomerByIdFetch.of(customerId));
final CompletionStage&lt;String&gt; pageStage = customerStage.thenApply(customerOption -&gt; "customer page " + customerOption);
</code><p>See the <a href="https://github.com/sphereio/sphere-jvm-sdk/blob/master/src/test/java/io/sphere/sdk/meta/AsyncDocumentationTest.java" target="_blank">test code</a>.</pre></div>


With <code>CompletionStage.thenApply(java.util.function.Function)</code> you apply a function to a stage
 if this stage completes successfully. The function is a first class member, so you can store it in a value or even make it the return type of
 a method.

 <div id="io-sphere-sdk-meta-AsyncDocumentationTest-thenApplyFirstDemoVerbose--%s" class=code-example><pre><code class='java'>final String customerId = "customer-id";
final CompletionStage&lt;Optional&lt;Customer&gt;&gt; customerStage = execute(CustomerByIdFetch.of(customerId));
final Function&lt;Optional&lt;Customer&gt;, String&gt; f = customerOption -&gt; "customer page " + customerOption;//stored in a value
final CompletionStage&lt;String&gt; pageStage = customerStage.thenApply(f);
</code><p>See the <a href="https://github.com/sphereio/sphere-jvm-sdk/blob/master/src/test/java/io/sphere/sdk/meta/AsyncDocumentationTest.java" target="_blank">test code</a>.</pre></div>

 <div id="io-sphere-sdk-meta-FunctionAsReturnValueDemo%s" class=code-example><button type='button' style='display: none;' class='reveal-imports'>show/hide imports</button><pre class='hide code-example-imports'><code class='java'>import io.sphere.sdk.customers.Customer;
import io.sphere.sdk.customers.queries.CustomerByIdFetch;
import java.util.Optional;
import java.util.concurrent.CompletionStage;
import java.util.function.Function;
</code></pre><pre><code class='java'>public class FunctionAsReturnValueDemo extends AsyncDocumentationTest {
    public static final Function&lt;Optional&lt;Customer&gt;, String&gt; renderCustomerPage(final String title) {
        return customerOption -&gt; title + " " + customerOption;
    }

    public static void showUsage() {
        final String customerId = "customer-id";
        final CompletionStage&lt;Optional&lt;Customer&gt;&gt; customerStage = execute(CustomerByIdFetch.of(customerId));
        final CompletionStage&lt;String&gt; pageStage = customerStage.thenApply(renderCustomerPage("customer page"));
    }
}
</code><p>See the <a href="https://github.com/sphereio/sphere-jvm-sdk/blob/master/src/test/java/io/sphere/sdk/meta/FunctionAsReturnValueDemo.java" target="_blank">test code</a>.</pre></div>

 It has similar semantics like <code>Stream.map(java.util.function.Function)</code>.

 <div id="io-sphere-sdk-meta-AsyncDocumentationTest-functionalCompositionMapStreamExample--%s" class=code-example><pre><code class='java'>final List&lt;Person&gt; persons = asList(new Person("John", "Smith"), new Person("Michael", "Müller"));
final List&lt;String&gt; lastNames = persons.stream().map(person -&gt; person.getLastName()).distinct().collect(toList());
assertThat(lastNames).containsExactly("Smith", "Müller");
</code><p>See the <a href="https://github.com/sphereio/sphere-jvm-sdk/blob/master/src/test/java/io/sphere/sdk/meta/AsyncDocumentationTest.java" target="_blank">test code</a>.</pre></div>



<h4>ThenCompose (flatMap, composition that returns a CompletionStage)</h4>

 Sometimes you run in situations where you create a new future inside a future.
 For example if you load a cart and want to fetch the first line item in it.


 <div id="io-sphere-sdk-meta-AsyncDocumentationTest-shouldUseFlatMap--%s" class=code-example><pre><code class='java'>final String cartIt = "cart-id";
final CompletionStage&lt;Optional&lt;Cart&gt;&gt; cartStage = execute(CartByIdFetch.of(cartIt));
final Function&lt;Optional&lt;Cart&gt;, CompletionStage&lt;Optional&lt;ProductProjection&gt;&gt;&gt; f = cartOption -&gt; {
    final LineItem lineItem = cartOption.get().getLineItems().get(0);
    final String productId = lineItem.getProductId();
    final CompletionStage&lt;Optional&lt;ProductProjection&gt;&gt; product = execute(ProductProjectionByIdFetch.of(productId, CURRENT));
    return product;
};
// CompletionStage of CompletionStage, urgs!
final CompletionStage&lt;CompletionStage&lt;Optional&lt;ProductProjection&gt;&gt;&gt; productStageStage = cartStage.thenApply(f);
</code><p>See the <a href="https://github.com/sphereio/sphere-jvm-sdk/blob/master/src/test/java/io/sphere/sdk/meta/AsyncDocumentationTest.java" target="_blank">test code</a>.</pre></div>

 Instead of creating an unmaintainable <code>CompletionStage</code> of <code>CompletionStage</code>,
 you can use <code>CompletionStage.thenCompose(java.util.function.Function)</code>.

 <div id="io-sphere-sdk-meta-AsyncDocumentationTest-flatMapFirstDemo--%s" class=code-example><pre><code class='java'>final String cartIt = "cart-id";
final CompletionStage&lt;Optional&lt;Cart&gt;&gt; cartStage = execute(CartByIdFetch.of(cartIt));
final Function&lt;Optional&lt;Cart&gt;, CompletionStage&lt;Optional&lt;ProductProjection&gt;&gt;&gt; f = cartOption -&gt; {
    final LineItem lineItem = cartOption.get().getLineItems().get(0);
    final String productId = lineItem.getProductId();
    final CompletionStage&lt;Optional&lt;ProductProjection&gt;&gt; product = execute(ProductProjectionByIdFetch.of(productId, CURRENT));
    return product;
};
//no nested CompletionStage, by using thenCompose instead of thenApply
final CompletionStage&lt;Optional&lt;ProductProjection&gt;&gt; productStageStage = cartStage.thenCompose(f);
</code><p>See the <a href="https://github.com/sphereio/sphere-jvm-sdk/blob/master/src/test/java/io/sphere/sdk/meta/AsyncDocumentationTest.java" target="_blank">test code</a>.</pre></div>

 It has similar semantics like <code>Stream.flatMap(java.util.function.Function)</code>.

 <div id="io-sphere-sdk-meta-AsyncDocumentationTest-functionalCompositionFlatMapStreamExample--%s" class=code-example><pre><code class='java'>final List&lt;Person&gt; persons = asList(new Person("John", "Smith"), new Person("Michael", "Müller"));
//map causes Stream of Stream
final Stream&lt;Stream&lt;Integer&gt;&gt; streamStream = persons.stream().map(person -&gt; person.getLastName().chars().boxed());
//flatMap
final Stream&lt;Integer&gt; simpleStream = persons.stream().flatMap(person -&gt; person.getLastName().chars().boxed());
assertThat(simpleStream.collect(toList())).containsExactly(83, 109, 105, 116, 104, 77, 252, 108, 108, 101, 114);

</code><p>See the <a href="https://github.com/sphereio/sphere-jvm-sdk/blob/master/src/test/java/io/sphere/sdk/meta/AsyncDocumentationTest.java" target="_blank">test code</a>.</pre></div>



 <!--



 map,flatmap mit future future
 only if no error occurred


 thread pool


 2 futures with thenCompose, after another

 thenCombine for when both completed


 -->

 <h3 id="callbacks">Callbacks</h3>







 <!--


 thenAccept/thenRun for side effects, value needed or not
for side effects
 println
 pseudo send server response
 -->

 <h3 id="creation">Creation and filling</h3>

 <h4>Creation of a successful future</h4>

 A future can be created fulfilled immediately:

 <div id="io-sphere-sdk-meta-AsyncDocumentationTest-createImmediatelyFulfilledFuture--%s" class=code-example><pre><code class='java'>final CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture("result");
</code><p>See the <a href="https://github.com/sphereio/sphere-jvm-sdk/blob/master/src/test/java/io/sphere/sdk/meta/AsyncDocumentationTest.java" target="_blank">test code</a>.</pre></div>

 Also future can be fulfilled later:

 <div id="io-sphere-sdk-meta-AsyncDocumentationTest-createFulfilledFuture--%s" class=code-example><pre><code class='java'>final CompletableFuture&lt;String&gt; future = new CompletableFuture&lt;&gt;();

assertThat(future.isDone()).isFalse();
assertThat(future.isCompletedExceptionally()).isFalse();

final String resultOfAComputation = "result";
future.complete(resultOfAComputation);

assertThat(future.isDone()).isTrue();
assertThat(future.isCompletedExceptionally()).isFalse();
</code><p>See the <a href="https://github.com/sphereio/sphere-jvm-sdk/blob/master/src/test/java/io/sphere/sdk/meta/AsyncDocumentationTest.java" target="_blank">test code</a>.</pre></div>

 For the immediately fulfilled future also exists an SDK utility method:

 <div id="io-sphere-sdk-meta-AsyncDocumentationTest-createImmediatelyFulfilledFutureShortcut--%s" class=code-example><pre><code class='java'>final CompletableFuture&lt;String&gt; future = CompletableFutureUtils.successful("result");
</code><p>See the <a href="https://github.com/sphereio/sphere-jvm-sdk/blob/master/src/test/java/io/sphere/sdk/meta/AsyncDocumentationTest.java" target="_blank">test code</a>.</pre></div>

 <h4>Creation of a failed future</h4>

 <div id="io-sphere-sdk-meta-AsyncDocumentationTest-createFailedFuture--%s" class=code-example><pre><code class='java'>final CompletableFuture&lt;String&gt; future = new CompletableFuture&lt;&gt;();

assertThat(future.isDone()).isFalse();
assertThat(future.isCompletedExceptionally()).isFalse();

final Throwable throwable = new Exception();
future.completeExceptionally(throwable);

assertThat(future.isDone()).isTrue();
assertThat(future.isCompletedExceptionally()).isTrue();
</code><p>See the <a href="https://github.com/sphereio/sphere-jvm-sdk/blob/master/src/test/java/io/sphere/sdk/meta/AsyncDocumentationTest.java" target="_blank">test code</a>.</pre></div>

 <p>Using a SDK shortcut:</p>
 <div id="io-sphere-sdk-meta-AsyncDocumentationTest-createFailedFutureShortcut--%s" class=code-example><pre><code class='java'>final CompletableFuture&lt;String&gt; future = CompletableFutureUtils.failed(new Exception());
</code><p>See the <a href="https://github.com/sphereio/sphere-jvm-sdk/blob/master/src/test/java/io/sphere/sdk/meta/AsyncDocumentationTest.java" target="_blank">test code</a>.</pre></div>


 <!--

 fulfilling in another thread

 normally only creator of future should be able to fulfill it, CompletionStage for outside access

difference Stage,Future
 promise,reedemable promise
 scala future, scala promise
 show threads used, fuer map/thenApply

 once it is filled, should be immutable


 static methods of completable future

 not null

 -->



 <h3 id="blocking">Blocking Access and Immediate Access</h3>
 <!-- CompletionStage.toCompletableFuture().join()

 occurring exception of join and what they mean
 CompletableFuture.getNow(valueIfAbsent)

 orElseThrow
 orElseGet wie bei Optional

 -->
 <h3 id="error-handling">Error Handling</h3>

 <!--

 try catch macht keinen sinn, exception ist im future
 recover & recoverWith

 handle for recover, ergebnis kann noch mal angepasst werden im nächsten stage
 handle kann auch optional zuruückgeben

 -->

 <!--

 <h3 id="ask-pattern">Ask pattern</h3>

 <code>&lt;pre&gt;
 public CompletableFuture&lt;T&gt; performTask() {
     final CompletableFuture&lt;T&gt; future = new CompletableFuture&lt;&gt;();
     //do here stuff async/non-blocking and return the future to the client
     return future;
 }

 &lt;/pre&gt;</code>

 -->

 <h3 id="multi-future">Working with multiple futures</h3>

 <!--
 2
 or list

 applyToEither to use the fasted of 2

 acceptEither
 -->


 <h3 id="traps">Traps</h3>
 <!--
 new CompletableFuture() and call future.get() and nether fill it, will block forever

 try catch mit ask pattern

 thenCompine and thenCompose, IDE may suggest the wrong one, sound similar

 toCompletableFuture.join(), especially in flatMap context


 -->
 <h3 id="advanced-examples">Advanced Examples</h3>

 <!--

    1000 listener for 1 future


 -->


 <h3 id="further-topics">Further Topics</h3>
 <!--
 skipable


 CompletableFuture.obtrudeValue, normally value will not be overridden
 -->


 <h3 id="further-sources">Further read and sources</h3>

<ul>
 <li><a href="http://docs.oracle.com/javase/8/docs/api/index.html?java/util/concurrent/CompletableFuture.html">CompletableFuture</a></li>
 <li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html">CompletionStage</a></li>
 <li><a href="http://www.nurkiewicz.com/2013/05/java-8-definitive-guide-to.html">Java 8: Definitive guide to CompletableFuture</a></li>
 <li><a href="http://www.nurkiewicz.com/2013/05/java-8-completablefuture-in-action.html">Java 8: CompletableFuture in action</a></li>
 </ul></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../io/sphere/sdk/meta/Architecture.html" title="class in io.sphere.sdk.meta"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../io/sphere/sdk/meta/BuildInfo.html" title="class in io.sphere.sdk.meta"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?io/sphere/sdk/meta/AsyncDocumentation.html" target="_top">Frames</a></li>
<li><a href="AsyncDocumentation.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#methods.inherited.from.class.java.lang.Object">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li>Method</li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small><link rel='stylesheet' href='http://yandex.st/highlightjs/7.4/styles/default.min.css'><script src='http://yandex.st/highlightjs/7.4/highlight.min.js'></script><script>hljs.initHighlightingOnLoad();</script><style>code {font-size: 1.0em;font-family: monospace;}</style><script src='https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js'></script>
<span id='custom-javascripts'></span>
<script>var pathPrefix = $(".navList a[href$='index-all.html']").attr("href").replace("index-all.html", ""); var closingScriptTag = "</" + "script>"; 
$('#custom-javascripts').append("<script src='" + pathPrefix + "documentation-resources/javascripts/main.js'>" + closingScriptTag + "<link rel='stylesheet' href='" + pathPrefix + "documentation-resources/stylesheets/main.css'>");</script></small></p>
</body>
</html>
